<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Charging Show</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">

<style>
  html, body { margin:0; height:100%; background:#000; overflow:hidden; }
  #wrap { position:relative; width:100%; height:100%; }

  /* TIME —— 33%，#f3803d */
  #time {
    position:absolute; top:33%; left:50%; transform:translate(-50%,-60%);
    font-family:-apple-system,BlinkMacSystemFont,"SF Pro Display","SF Pro Text",Inter,Arial,sans-serif;
    font-weight:800; font-size:min(22vw,130px); letter-spacing:2px;
    color:#f3803d; text-shadow:0 0 14px rgba(243,128,61,0.40);
    -webkit-font-smoothing:antialiased; user-select:none; transition:opacity .15s ease;
  }
  #label {
    position:absolute; top:calc(35% + min(15vw,90px)); left:50%; transform:translateX(-50%);
    display:flex; align-items:center; gap:min(6vw, 28px);
    color:#e7e7e7; font-size:min(5.6vw,24px); opacity:.95; user-select:none; transition:opacity .15s ease;
  }

  /* 键帽 */
  #key{
    display:inline-block; width:26px; height:26px; line-height:26px; border-radius:5px;
    background:linear-gradient(#4b4b4b,#2f2f2f); border:1px solid #0e0e0e;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.14), inset 0 -2px 0 rgba(0,0,0,.55), 0 1px 0 rgba(255,255,255,.06), 0 2px 6px rgba(0,0,0,.55);
    color:#e9e9e9; font-weight:700; font-size:14px; text-align:center; letter-spacing:.2px; text-shadow:0 -1px 0 rgba(0,0,0,.6);
    font-family:ui-monospace,SFMono-Regular,Menlo,monospace; position:relative; user-select:none;
  }
  #key::before{ content:""; position:absolute; inset:2px; border-radius:4px; border:1px solid rgba(255,255,255,.10); box-shadow:inset 0 0 0 1px rgba(0,0,0,.50); }
  #key::after{ content:""; position:absolute; left:3px; top:3px; width:55%; height:42%; border-radius:4px; background:radial-gradient(ellipse at top left, rgba(255,255,255,.18), rgba(255,255,255,0) 60%); pointer-events:none; }

  #cv { position:absolute; inset:0; display:block; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="cv"></canvas>
  <div id="time">10:20</div>
  <div id="label"><span id="key">E</span><span>Wake Up</span></div>
</div>

<script>
  // ===== 画布 & 时间 =====
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d",{alpha:true});
  function resize(){ cv.width=innerWidth; cv.height=innerHeight; }
  resize(); addEventListener("resize", resize);

  const timeEl = document.getElementById("time");
  const labelEl = document.getElementById("label");
  const pad = n => (n<10?("0"+n):n);
  function tickTime(){ const d=new Date(); timeEl.textContent = pad(d.getHours())+":"+pad(d.getMinutes()); }
  tickTime(); setInterval(tickTime,1000);

  // ===== 背景图：bg.jpg（可选） =====
  const bgImg = new Image(); let bgReady=false;
  bgImg.onload=()=>bgReady=true; bgImg.onerror=()=>bgReady=false;
  bgImg.src="bg.jpg"; // 没有也能运行

  // ===== 粒子（保持你当前参数） =====
  const embers=[]; function randTri(){ return Math.random()+Math.random()-1; }
  function spawnEmber(){
    const w=cv.width,h=cv.height;
    const BASE_X=0.60, BASE_Y=0.78, SPREAD_X=0.32, SPREAD_Y=0.18;
    const x = w*BASE_X + randTri()*w*(SPREAD_X/2);
    const y = h*BASE_Y + randTri()*h*(SPREAD_Y/2);
    const vy0 = -(120 + Math.random()*110);
    const vx0 = (Math.random()-0.5) * 40;
    const life = 2.6 + Math.random()*1.8;
    const size = 1.7 + Math.random()*2.5;
    const hue  = 10 + Math.random()*8;
    embers.push({x,y,vx:vx0,vy:vy0,age:0,life,size,hue,wobble:(Math.random()*2+1)*(Math.random()<0.5?-1:1)});
  }
  (function schedule(){ const ms=700+Math.random()*2300; setTimeout(()=>{ spawnEmber(); schedule(); }, ms); })();

  // ===== 眼睛动画参数（扁椭圆 + 羽化 + 融合） =====
  const EYES = {
    openDur: 900,   // 睁开 ms
    holdDur: 420,   // 停留 ms
    mergeDur: 200,  // 四眼 → 扁椭圆扫开全屏
    fadeDur: 220,   // 最终淡出
    rxScale: 0.17,  // 单个“眼缝”横向半径 = min(w,h)*rxScale
    ryRatio: 0.32,  // 纵向半径 = rx*ryRatio （越小越扁）
    feather: 26     // 羽化像素（边缘柔和程度）
  };
  function easeOutCubic(x){ return 1-Math.pow(1-x,3); }
  function clamp01(v){ return Math.max(0,Math.min(1,v)); }

  // ===== 状态机 =====
  let mode="main", tStart=0;
  let last=performance.now();
  requestAnimationFrame(loop);

  function loop(now){
    const dt=Math.min(0.033,(now-last)/1000); last=now;
    ctx.clearRect(0,0,cv.width,cv.height);

    if(mode==="main"){
      drawMain(dt);
    }else{
      drawEyes(now);
    }
    requestAnimationFrame(loop);
  }

  function drawMain(dt){
    // 画背景（保持暗一些，突出粒子与文字）
    if(bgReady) drawBG(cv.width,cv.height,0.92);
    // 画粒子
    for(let i=embers.length-1;i>=0;i--){
      const p=embers[i];
      p.age+=dt; p.vy+=20*dt; p.vx+=p.wobble*dt; p.x+=p.vx*dt; p.y+=p.vy*dt;
      const k=Math.max(0,1-p.age/p.life);
      const alpha=0.9*Math.pow(k,0.7);
      const light=45+Math.sin(p.age*18)*5;
      ctx.save(); ctx.globalCompositeOperation="lighter";
      ctx.shadowColor="hsla("+p.hue+",100%,60%,"+alpha+")";
      ctx.shadowBlur=25;
      ctx.beginPath(); ctx.fillStyle="hsla("+p.hue+",100%,"+light+"%,"+alpha+")";
      ctx.arc(p.x,p.y,p.size*(0.8+0.7*k),0,Math.PI*2); ctx.fill(); ctx.restore();
      if(p.age>=p.life) embers.splice(i,1);
    }
  }

  // 点击进入眼睛动画
  addEventListener("click", ()=>{
    if(mode!=="main") return;
    mode="eyes"; tStart=performance.now();
    embers.length=0; timeEl.style.opacity=0; labelEl.style.opacity=0;
  });

  function drawEyes(now){
    const w=cv.width,h=cv.height,s=Math.min(w,h);
    // 先完整画背景
    if(bgReady) drawBG(w,h,1); else { ctx.fillStyle="#000"; ctx.fillRect(0,0,w,h); }

    // 再盖一层全黑 → 用 destination-out 以“羽化的扁椭圆”从黑里挖洞
    ctx.save();
    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = "rgba(0,0,0,1)";
    ctx.fillRect(0,0,w,h);

    ctx.globalCompositeOperation = "destination-out";
    const rx = s*EYES.rxScale;
    const ry = rx*EYES.ryRatio;
    const gapX = s*0.18, gapY = s*0.20;
    const cx = w*0.5, cy = h*0.52;
    const centers = [
      [cx-gapX, cy-gapY], [cx+gapX, cy-gapY],
      [cx-gapX, cy+gapY], [cx+gapX, cy+gapY],
    ];

    const t = now - tStart;
    const pOpen  = clamp01(t/EYES.openDur);
    const openY  = Math.max(0.001, easeOutCubic(pOpen)); // 眼缝由 0→1
    const pHold  = clamp01((t-EYES.openDur)/EYES.holdDur);
    const pMerge = clamp01((t-EYES.openDur-EYES.holdDur)/EYES.mergeDur);
    const pFade  = clamp01((t-EYES.openDur-EYES.holdDur-EYES.mergeDur)/EYES.fadeDur);

    // —— 四只扁椭圆：先实心挖洞，再用 shadowBlur 输出羽化
    centers.forEach(([x,y])=>{
      // 实心洞
      ctx.save();
      ctx.translate(x,y); ctx.scale(1,openY);
      ctx.beginPath(); ctx.ellipse(0,0,rx,ry,0,0,Math.PI*2);
      ctx.fillStyle="#fff"; ctx.fill(); // destination-out：把黑遮罩挖掉
      // 羽化边
      ctx.shadowColor="#fff"; ctx.shadowBlur=EYES.feather;
      ctx.fill(); // 再填一次，shadow 作为“柔边”继续挖淡化区域
      ctx.restore();
    });

    // —— 四眼互相融合：用一个巨大且同样扁的椭圆快速扫开
    if(pMerge>0){
      const k=easeOutCubic(pMerge);
      const R = Math.hypot(w,h) * (0.08 + 1.2*k);
      ctx.save();
      ctx.beginPath();
      ctx.ellipse(cx, cy, R, R*EYES.ryRatio, 0, 0, Math.PI*2);
      // 同样做羽化边
      ctx.fillStyle="#fff"; ctx.fill();
      ctx.shadowColor="#fff"; ctx.shadowBlur=EYES.feather*1.1;
      ctx.fill();
      ctx.restore();
    }

    // 覆层完成
    ctx.restore();

    // 最终淡出（整屏到黑）
    if(pFade>0){
      ctx.fillStyle="rgba(0,0,0,"+pFade+")";
      ctx.fillRect(0,0,w,h);
    }
    if(pFade>=1){ setTimeout(()=>{ window.close(); }, 10); }
  }

  // 背景 cover；alpha 控整体亮度
  function drawBG(w,h,alpha){
    const img=bgImg; if(!bgReady){ ctx.fillStyle="#000"; ctx.fillRect(0,0,w,h); return; }
    const iw=img.naturalWidth||img.width, ih=img.naturalHeight||img.height;
    const r=Math.max(w/iw,h/ih), dw=iw*r, dh=ih*r, dx=(w-dw)/2, dy=(h-dh)/2;
    ctx.save(); ctx.globalAlpha=alpha; ctx.drawImage(img,dx,dy,dw,dh); ctx.restore();
  }
</script>
</body>
</html>
