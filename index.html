<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Charging Show</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  html, body { height:100%; background:#000; overflow:hidden; }
  
  #wrap { position:relative; width:100%; height:100%; }
  
  /* 背景层：你的手机截图 */
  #bgLayer { 
    position:absolute; inset:0; 
    background-size:cover; background-position:center; 
    /* 默认用渐变，等图片加载后会被替换 */
    background-image: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
  }
  
  /* 遮罩层：纯黑色 canvas，用来挖洞 */
  #maskCanvas { position:absolute; inset:0; }
  
  /* 粒子层 */
  #particleCanvas { position:absolute; inset:0; pointer-events:none; }

  /* 时间显示 */
  #time {
    position:absolute; top:33%; left:50%; transform:translate(-50%,-60%);
    font-family:-apple-system,BlinkMacSystemFont,"SF Pro Display",Inter,Arial,sans-serif;
    font-weight:800; font-size:min(22vw,130px); letter-spacing:2px;
    color:#f3803d; text-shadow:0 0 14px rgba(243,128,61,0.40);
    -webkit-font-smoothing:antialiased; user-select:none; 
    transition:opacity .3s ease; pointer-events:none;
  }
  
  #label {
    position:absolute; top:calc(35% + min(15vw,90px)); left:50%; transform:translateX(-50%);
    display:flex; align-items:center; gap:min(6vw, 28px);
    color:#e7e7e7; font-size:min(5.6vw,24px); opacity:.95; user-select:none;
    transition:opacity .3s ease; pointer-events:none;
  }

  #key{
    display:inline-block; width:26px; height:26px; line-height:26px; border-radius:5px;
    background:linear-gradient(#4b4b4b,#2f2f2f); border:1px solid #0e0e0e;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.14), inset 0 -2px 0 rgba(0,0,0,.55), 
                0 1px 0 rgba(255,255,255,.06), 0 2px 6px rgba(0,0,0,.55);
    color:#e9e9e9; font-weight:700; font-size:14px; text-align:center; 
    letter-spacing:.2px; text-shadow:0 -1px 0 rgba(0,0,0,.6);
    font-family:ui-monospace,SFMono-Regular,Menlo,monospace; position:relative;
  }
  #key::before{ 
    content:""; position:absolute; inset:2px; border-radius:4px; 
    border:1px solid rgba(255,255,255,.10); box-shadow:inset 0 0 0 1px rgba(0,0,0,.50); 
  }
  #key::after{ 
    content:""; position:absolute; left:3px; top:3px; width:55%; height:42%; border-radius:4px; 
    background:radial-gradient(ellipse at top left, rgba(255,255,255,.18), transparent 60%); 
  }

  #debug { 
    position:absolute; bottom:10px; left:10px; 
    color:#888; font-size:11px; font-family:monospace; 
    background:rgba(0,0,0,.5); padding:4px 8px; border-radius:4px;
    pointer-events:none;
  }
</style>
</head>
<body>
<div id="wrap">
  <!-- 背景层 -->
  <div id="bgLayer"></div>
  
  <!-- 遮罩层 canvas -->
  <canvas id="maskCanvas"></canvas>
  
  <!-- 粒子层 canvas -->
  <canvas id="particleCanvas"></canvas>
  
  <!-- UI 层 -->
  <div id="time">10:20</div>
  <div id="label"><span id="key">E</span><span>Wake Up</span></div>
  <div id="debug">加载中...</div>
</div>

<script>
  const bgLayer = document.getElementById("bgLayer");
  const maskCv = document.getElementById("maskCanvas");
  const maskCtx = maskCv.getContext("2d");
  const particleCv = document.getElementById("particleCanvas");
  const particleCtx = particleCv.getContext("2d", {alpha:true});
  const timeEl = document.getElementById("time");
  const labelEl = document.getElementById("label");
  const debugEl = document.getElementById("debug");

  // 调整画布尺寸
  function resize(){ 
    maskCv.width = particleCv.width = innerWidth; 
    maskCv.height = particleCv.height = innerHeight; 
  }
  resize(); 
  addEventListener("resize", resize);

  // 时间更新
  const pad = n => (n < 10 ? "0" + n : n);
  function tickTime(){ 
    const d = new Date(); 
    timeEl.textContent = pad(d.getHours()) + ":" + pad(d.getMinutes()); 
  }
  tickTime(); 
  setInterval(tickTime, 1000);

  // ===== 加载背景图片 =====
  let bgImageLoaded = false;
  const bgImg = new Image();
  
  bgImg.onload = () => {
    bgImageLoaded = true;
    // 用加载的图片替换背景
    bgLayer.style.backgroundImage = `url(${bgImg.src})`;
    debugEl.textContent = `✓ 图片已加载 | 点击屏幕开始`;
    console.log("背景加载成功", bgImg.naturalWidth, bgImg.naturalHeight);
  };
  
  bgImg.onerror = (e) => {
    console.error("背景加载失败", e);
    debugEl.textContent = "⚠ 图片加载失败，使用默认背景";
    // 失败也允许继续，只是用默认渐变背景
    bgImageLoaded = true; 
  };

  // 方式1: 使用相对路径（需要bg.jpg在同目录）
  // bgImg.src = "bg.jpg";
  
  // 方式2: 使用 base64（把截图转成 base64 粘贴这里）
  // bgImg.src = "data:image/jpeg;base64,/9j/4AAQ...";
  
  // 方式3: 临时测试背景（模拟星际拓荒营火场景）
  bgImg.src = "data:image/svg+xml," + encodeURIComponent(`
    <svg xmlns="http://www.w3.org/2000/svg" width="400" height="800">
      <defs>
        <radialGradient id="fire" cx="50%" cy="70%">
          <stop offset="0%" style="stop-color:#ff6b35"/>
          <stop offset="50%" style="stop-color:#f7931e"/>
          <stop offset="100%" style="stop-color:#1a1a1a"/>
        </radialGradient>
      </defs>
      <rect width="400" height="800" fill="#0a0a0a"/>
      <ellipse cx="200" cy="560" rx="120" ry="80" fill="url(#fire)" opacity="0.8"/>
      <text x="200" y="400" font-size="32" fill="#e94560" text-anchor="middle" font-family="Arial">
        营火场景
      </text>
      <text x="200" y="440" font-size="18" fill="#888" text-anchor="middle" font-family="Arial">
        (替换成你的手机截图)
      </text>
    </svg>
  `);

  // ===== 粒子系统（火花效果）=====
  const embers = []; 
  let spawnActive = true;
  
  function randTri(){ return Math.random() + Math.random() - 1; }
  
  function spawnEmber(){
    if (!spawnActive) return;
    const w = particleCv.width, h = particleCv.height;
    const x = w * 0.60 + randTri() * w * 0.16;
    const y = h * 0.78 + randTri() * h * 0.09;
    const vy0 = -(120 + Math.random() * 110);
    const vx0 = (Math.random() - 0.5) * 40;
    const life = 2.6 + Math.random() * 1.8;
    const size = 1.7 + Math.random() * 2.5;
    const hue = 10 + Math.random() * 8;
    
    embers.push({
      x, y, vx: vx0, vy: vy0, age: 0, life, size, hue,
      wobble: (Math.random() * 2 + 1) * (Math.random() < 0.5 ? -1 : 1)
    });
    
    setTimeout(spawnEmber, 700 + Math.random() * 2300);
  }
  setTimeout(spawnEmber, 300);

  // ===== 眼睛动画参数 =====
  const EYES_CONFIG = {
    duration: 1400,       // 睁眼时长
    featherSize: 50,      // 羽化边缘大小（更大让融合更自然）
    eyeRadiusX: 0.25,     // 眼睛横向半径（更长）
    eyeRadiusYRatio: 0.15, // 纵向半径比例（更扁，更像真实眼睛）
    gapX: 0.12,           // 四个眼睛的间距（更近，容易融合）
    gapY: 0.10,
    expandScale: 2.8      // 最终扩张倍数（让眼睛最后扩大覆盖整个屏幕）
  };
  
  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
  function clamp01(v){ return Math.max(0, Math.min(1, v)); }

  // ===== 状态机 =====
  let mode = "main";  // "main" 或 "opening"
  let openStartTime = 0;
  let lastTime = performance.now();
  
  requestAnimationFrame(loop);

  function loop(now){
    const dt = Math.min(0.033, (now - lastTime) / 1000); 
    lastTime = now;

    if (mode === "main"){
      drawMainState(dt);
    } else if (mode === "opening"){
      drawOpeningState(now);
    }
    
    requestAnimationFrame(loop);
  }

  // 主状态：显示粒子 + 纯黑遮罩
  function drawMainState(dt){
    // 遮罩层绘制纯黑
    maskCtx.fillStyle = "#000";
    maskCtx.fillRect(0, 0, maskCv.width, maskCv.height);
    
    // 粒子层绘制火花
    particleCtx.clearRect(0, 0, particleCv.width, particleCv.height);
    
    for (let i = embers.length - 1; i >= 0; i--){
      const p = embers[i];
      p.age += dt; 
      p.vy += 20 * dt; 
      p.vx += p.wobble * dt; 
      p.x += p.vx * dt; 
      p.y += p.vy * dt;
      
      const k = Math.max(0, 1 - p.age / p.life);
      const alpha = 0.9 * Math.pow(k, 0.7);
      const light = 45 + Math.sin(p.age * 18) * 5;
      
      particleCtx.save(); 
      particleCtx.globalCompositeOperation = "lighter";
      particleCtx.shadowColor = `hsla(${p.hue},100%,60%,${alpha})`;
      particleCtx.shadowBlur = 25;
      particleCtx.beginPath(); 
      particleCtx.fillStyle = `hsla(${p.hue},100%,${light}%,${alpha})`;
      particleCtx.arc(p.x, p.y, p.size * (0.8 + 0.7 * k), 0, Math.PI * 2); 
      particleCtx.fill(); 
      particleCtx.restore();
      
      if (p.age >= p.life) embers.splice(i, 1);
    }
  }

  // 睁眼状态：用 destination-out 挖四个椭圆洞，逐渐扩大并融合
  function drawOpeningState(now){
    const w = maskCv.width, h = maskCv.height;
    const s = Math.min(w, h);
    
    // 先画纯黑遮罩
    maskCtx.fillStyle = "#000";
    maskCtx.fillRect(0, 0, w, h);
    
    // 计算睁眼进度
    const elapsed = now - openStartTime;
    const progress = clamp01(elapsed / EYES_CONFIG.duration);
    
    // 分两个阶段：
    // 0-0.6: 睁眼（纵向打开）
    // 0.6-1.0: 扩张并融合（整体放大）
    const openPhase = Math.min(1, progress / 0.6);
    const expandPhase = Math.max(0, (progress - 0.6) / 0.4);
    
    const openScale = easeOutCubic(openPhase);  // 纵向睁开
    const expandScale = 1 + (EYES_CONFIG.expandScale - 1) * easeOutCubic(expandPhase); // 整体扩张
    
    // 用 destination-out 模式挖洞
    maskCtx.save();
    maskCtx.globalCompositeOperation = "destination-out";
    
    const rxBase = s * EYES_CONFIG.eyeRadiusX * expandScale;
    const ryBase = rxBase * EYES_CONFIG.eyeRadiusYRatio;
    const gapX = s * EYES_CONFIG.gapX / expandScale; // 间距随扩张缩小，让眼睛靠近
    const gapY = s * EYES_CONFIG.gapY / expandScale;
    const cx = w * 0.5, cy = h * 0.52;
    
    // 四个眼睛的位置
    const eyePositions = [
      [cx - gapX, cy - gapY], // 左上
      [cx + gapX, cy - gapY], // 右上
      [cx - gapX, cy + gapY], // 左下
      [cx + gapX, cy + gapY]  // 右下
    ];

    eyePositions.forEach(([ex, ey]) => {
      maskCtx.save();
      maskCtx.translate(ex, ey);
      maskCtx.scale(1, Math.max(0.001, openScale)); // 纵向缩放模拟睁眼
      
      // 绘制实心椭圆（会变成透明洞）
      maskCtx.beginPath();
      maskCtx.ellipse(0, 0, rxBase, ryBase, 0, 0, Math.PI * 2);
      maskCtx.fillStyle = "#fff";
      maskCtx.fill();
      
      // 添加羽化效果（模糊边缘，让四个眼睛容易融合）
      maskCtx.shadowColor = "#fff";
      maskCtx.shadowBlur = EYES_CONFIG.featherSize * expandScale;
      maskCtx.fill();
      
      maskCtx.restore();
    });
    
    maskCtx.restore();
    
    // 粒子层清空（睁眼时不显示火花）
    particleCtx.clearRect(0, 0, particleCv.width, particleCv.height);
    
    // 动画结束后关闭页面
    if (progress >= 1){
      setTimeout(() => { 
        debugEl.textContent = "动画完成";
        // window.close(); // 取消注释以自动关闭
      }, 100);
    }
  }

  // ===== 点击/触摸触发睁眼动画 =====
  function startOpening(e) {
    // 阻止默认行为和冒泡
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    
    if (mode !== "main") {
      console.log("已经在动画状态，忽略");
      return;
    }
    
    if (!bgImageLoaded){
      debugEl.textContent = "⚠ 等待图片加载...";
      debugEl.style.color = "#f00";
      console.log("图片未加载完成");
      return;
    }
    
    console.log("开始睁眼动画");
    mode = "opening";
    openStartTime = performance.now();
    spawnActive = false;  // 停止生成新粒子
    embers.length = 0;    // 清空现有粒子
    
    // 隐藏文字
    timeEl.style.opacity = 0;
    labelEl.style.opacity = 0;
    debugEl.textContent = "睁眼中...";
  }
  
  // 同时监听 click 和 touchstart
  document.body.addEventListener("click", startOpening, false);
  document.body.addEventListener("touchstart", startOpening, {passive: false});
</script>
</body>
</html>
