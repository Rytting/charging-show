<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Charging Show</title>

<!-- iOS 独立全屏（无地址栏/工具条） -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">

<style>
  html, body { margin:0; height:100%; background:#000; overflow:hidden; }
  #wrap { position:relative; width:100%; height:100%; }

  /* TIME —— 33%，#f3803d */
  #time {
    position:absolute; top:33%; left:50%; transform:translate(-50%,-60%);
    font-family:-apple-system,BlinkMacSystemFont,"SF Pro Display","SF Pro Text",Inter,Arial,sans-serif;
    font-weight:800; font-size:min(22vw,130px); letter-spacing:2px;
    color:#f3803d; text-shadow:0 0 14px rgba(243,128,61,0.40);
    -webkit-font-smoothing:antialiased; user-select:none; transition:opacity .15s ease;
  }

  /* LABEL —— 跟随时间；间距自适应 */
  #label {
    position:absolute; top:calc(35% + min(15vw,90px)); left:50%; transform:translateX(-50%);
    display:flex; align-items:center; gap:min(6vw, 28px);
    color:#e7e7e7; font-size:min(5.6vw,24px); opacity:.95; user-select:none; transition:opacity .15s ease;
  }

  /* 键帽 */
  #key{
    display:inline-block; width:26px; height:26px; line-height:26px; border-radius:5px;
    background:linear-gradient(#4b4b4b,#2f2f2f); border:1px solid #0e0e0e;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.14), inset 0 -2px 0 rgba(0,0,0,.55), 0 1px 0 rgba(255,255,255,.06), 0 2px 6px rgba(0,0,0,.55);
    color:#e9e9e9; font-weight:700; font-size:14px; text-align:center; letter-spacing:.2px; text-shadow:0 -1px 0 rgba(0,0,0,.6);
    font-family:ui-monospace,SFMono-Regular,Menlo,monospace; position:relative; user-select:none;
  }
  #key::before{ content:""; position:absolute; inset:2px; border-radius:4px; border:1px solid rgba(255,255,255,.10); box-shadow:inset 0 0 0 1px rgba(0,0,0,.50); }
  #key::after{ content:""; position:absolute; left:3px; top:3px; width:55%; height:42%; border-radius:4px; background:radial-gradient(ellipse at top left, rgba(255,255,255,.18), rgba(255,255,255,0) 60%); pointer-events:none; }

  #cv { position:absolute; inset:0; display:block; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="cv"></canvas>
  <div id="time">10:20</div>
  <div id="label"><span id="key">E</span><span>Wake Up</span></div>
</div>

<script>
  // ========= 画布 & 时间 =========
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d",{alpha:true});
  function resize(){ cv.width=innerWidth; cv.height=innerHeight; }
  resize(); addEventListener("resize", resize);

  const timeEl = document.getElementById("time");
  const labelEl = document.getElementById("label");
  const pad = n => (n<10?("0"+n):n);
  function tickTime(){ const d=new Date(); timeEl.textContent = pad(d.getHours())+":"+pad(d.getMinutes()); }
  tickTime(); setInterval(tickTime,1000);

  // ========= 预载主屏图（bg.jpg），失败则置空用黑色 =========
  const bgImg = new Image();
  let bgReady = false;
  bgImg.onload = ()=> bgReady = true;
  bgImg.onerror = ()=> bgReady = false;
  bgImg.src = "bg.jpg"; // 把你的主屏截图命名为 bg.jpg 丢到同目录

  // ========= 粒子（沿用你当前参数） =========
  const embers=[]; function randTri(){ return Math.random()+Math.random()-1; }
  function spawnEmber(){
    const w=cv.width,h=cv.height;
    const BASE_X=0.60, BASE_Y=0.78, SPREAD_X=0.32, SPREAD_Y=0.18;
    const x = w*BASE_X + randTri()*w*(SPREAD_X/2);
    const y = h*BASE_Y + randTri()*h*(SPREAD_Y/2);
    const vy0 = -(120 + Math.random()*110);
    const vx0 = (Math.random()-0.5) * 40;
    const life = 2.6 + Math.random()*1.8;
    const size = 1.7 + Math.random()*2.5;
    const hue  = 10 + Math.random()*8;
    embers.push({x,y,vx:vx0,vy:vy0,age:0,life,size,hue,wobble:(Math.random()*2+1)*(Math.random()<0.5?-1:1)});
  }
  (function schedule(){ const ms=700+Math.random()*2300; setTimeout(()=>{ spawnEmber(); schedule(); }, ms); })();

  // ========= 状态：主界面 → 眼睛开合 → 结束 =========
  let mode = "main"; // "main" | "eyes"
  let tStart = 0;

  // 眼睛动画参数（更贴近原作节奏）
  const EYES = {
    openDur: 900,   // 睁开时长 ms
    holdDur: 400,   // 停留 ms
    sweepDur: 180,  // 从四眼迅速“扫开全屏”的时间
    fadeDur: 220,   // 最后淡出
    ringColor: "#f3803d",
    glowBlur: 28
  };

  function easeOutCubic(x){ return 1 - Math.pow(1 - x, 3); }
  function clamp01(v){ return Math.max(0, Math.min(1, v)); }

  // 主循环
  let last=performance.now();
  function loop(now){
    const dt=Math.min(0.033,(now-last)/1000); last=now;
    ctx.clearRect(0,0,cv.width,cv.height);

    if(mode==="main"){
      // 画粒子
      for(let i=embers.length-1;i>=0;i--){
        const p=embers[i];
        p.age+=dt; p.vy+=20*dt; p.vx+=p.wobble*dt; p.x+=p.vx*dt; p.y+=p.vy*dt;
        const k=Math.max(0,1-p.age/p.life);
        const alpha=0.9*Math.pow(k,0.7);
        const light=45+Math.sin(p.age*18)*5;
        ctx.save(); ctx.globalCompositeOperation="lighter";
        ctx.shadowColor="hsla("+p.hue+",100%,60%,"+alpha+")";
        ctx.shadowBlur=25;
        ctx.beginPath(); ctx.fillStyle="hsla("+p.hue+",100%,"+light+"%,"+alpha+")";
        ctx.arc(p.x,p.y,p.size*(0.8+0.7*k),0,Math.PI*2); ctx.fill(); ctx.restore();
        if(p.age>=p.life) embers.splice(i,1);
      }
    } else if(mode==="eyes"){
      drawEyes(now);
    }

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // 点击进入眼睛动画
  addEventListener("click", ()=>{
    if(mode!=="main") return;
    mode="eyes";
    tStart=performance.now();
    embers.length=0;
    timeEl.style.opacity=0;
    labelEl.style.opacity=0;
  });

  // 画“眼睛开合”并通过剪裁显示 bg.jpg
  function drawEyes(now){
    const w=cv.width,h=cv.height;
    const s = Math.min(w,h);
    // 四眼布局（2×2）
    const radius = s*0.12;
    const gapX = s*0.18, gapY = s*0.20;
    const cx = w*0.5, cy = h*0.52;
    const centers = [
      [cx-gapX, cy-gapY], [cx+gapX, cy-gapY],
      [cx-gapX, cy+gapY], [cx+gapX, cy+gapY],
    ];

    const t = now - tStart;
    const {openDur, holdDur, sweepDur, fadeDur} = EYES;

    // 进度段
    const pOpen = clamp01(t/openDur);
    const openY = Math.max(0.001, easeOutCubic(pOpen));   // 眼睑开合（Y缩放）
    const pHold = clamp01((t-openDur)/holdDur);
    const pSweep = clamp01((t-openDur-holdDur)/sweepDur); // 四眼 → 全屏
    const pFade = clamp01((t-openDur-holdDur-sweepDur)/fadeDur);

    // 背景底色
    ctx.fillStyle = "black";
    ctx.fillRect(0,0,w,h);

    // —— 先做剪裁：四只“椭圆眼”区域 + 后续扫开
    ctx.save();
    // 四只眼的剪裁
    centers.forEach(([x,y])=>{
      ctx.save();
      ctx.translate(x,y);
      ctx.scale(1, openY);                    // 从闭眼(0)到睁眼(1)
      ctx.beginPath();
      ctx.ellipse(0,0, radius, radius*0.86, 0, 0, Math.PI*2);
      ctx.clip();
      // 在这个剪裁里画背景图
      drawBG(w,h);
      ctx.restore();

      // 外环发光（只为了还原质感）
      ctx.save();
      ctx.translate(x,y);
      ctx.scale(1, openY);
      ctx.beginPath();
      ctx.shadowColor = EYES.ringColor;
      ctx.shadowBlur  = EYES.glowBlur * (0.6 + 0.4*openY);
      ctx.strokeStyle = EYES.ringColor;
      ctx.lineWidth   = Math.max(2, radius*0.12);
      ctx.ellipse(0,0, radius, radius*0.86, 0, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    });

    // —— 四眼扫开到全屏：逐步扩大一个超大椭圆剪裁，填充整屏背景
    if(pSweep>0){
      const k = easeOutCubic(pSweep);
      const R = Math.hypot(w,h)*0.7*(0.1 + 1.2*k); // 快速增大半径
      ctx.save();
      ctx.beginPath();
      ctx.ellipse(cx, cy, R, R*0.86, 0, 0, Math.PI*2);
      ctx.clip();
      drawBG(w,h);
      ctx.restore();
    }
    ctx.restore();

    // 最终淡出
    if(pFade>0){
      ctx.fillStyle = "rgba(0,0,0,"+pFade+")";
      ctx.fillRect(0,0,w,h);
    }
    if(pFade>=1){
      setTimeout(()=>{ window.close(); }, 10);
    }
  }

  // 把背景图按 cover 方式铺满（16:9/长屏都合适）；无图时黑色
  function drawBG(w,h){
    if(!bgReady){ return; }
    const img = bgImg;
    const iw = img.naturalWidth || img.width;
    const ih = img.naturalHeight || img.height;
    // cover 算法
    const r = Math.max(w/iw, h/ih);
    const dw = iw*r, dh = ih*r;
    const dx = (w - dw)/2, dy = (h - dh)/2;
    // 轻微变暗，跟原作更像
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.drawImage(img, dx, dy, dw, dh);
    ctx.restore();
  }
</script>
</body>
</html>

